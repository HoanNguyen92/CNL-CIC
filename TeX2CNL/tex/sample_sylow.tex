
\documentclass[12pt]{article}


% PACKAGES
\usepackage{url}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{currfile}
\usepackage{fancyvrb}
\usepackage{xparse} % needed for \ellipsis control sequence in cnl-style

% for underscores https://texfaq.org/FAQ-underscore
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{lineno}

\usepackage[
bookmarksopen,
bookmarksdepth=2,
%breaklinks=true
colorlinks=true,
urlcolor=blue]{hyperref}

% GLOBAL FORMATTING
%\linenumbers
\parindent=0pt
\parskip=0.5\baselineskip
\raggedbottom

% TITLE AUTHOR DATE
\title{Sample Controlled Natural Language text,\\ including real numbers and Sylows theorems}

\date{August 14, 2019}
\author{Thomas Hales}

% THEOREMS
\newtheorem{definition}{Definition}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{lemma}[definition]{Lemma}
%\newtheorem{specification}[definition]{Specification}


% DOCUMENT

\begin{document}
\maketitle

\newenvironment{envMatch}%
               {\par\begin{tabular}{@{\quad\normalfont| }lll}}%
               {\end{tabular}\par}
               \newcommand{\matchitem}{\\}
               \newcommand{\firstmatchitem}{}

               \newcommand\caseif[2]{#1 & \condif\ #2}
               \newcommand\caseotherwise[1]{#1&\otherwise}

\newenvironment{structure}%
{\begin{itemize}}
{\end{itemize}}
\newcommand{\firstitem}{\item}

\newenvironment{make}                              
{\begin{itemize}}
{\end{itemize}}




%\renewcommand\labelitemi{\normalfont|}}


%% ELLIPSIS, 
% based on Luis Berlioz's query
% https://tex.stackexchange.com/questions/503731/how-to-define-a-macro-that-takes-the-definition-of-a-macro-as-an-argument
% \usepackage{amsmath}
% \usepackage{xparse}

\ExplSyntaxOn
\NewDocumentCommand{\ellipsis}{mmmm}
 {% #1 = main term
  % #2 = first index
  % #3 = last index
  % #4 = operation
  \group_begin:
  \lucas_ellipsis:nnnn { #1 } { #2 } { #3 } { #4 }
  \group_end:
 }
\cs_new:Nn \lucas_ellipsis:nnnn
 {
  \cs_set:Nn \__lucas_ellipsis_term:n { #1 }
  \__lucas_ellipsis_term:n { #2 }
  #4 \dots #4
  \__lucas_ellipsis_term:n { #3 }
 }
\ExplSyntaxOff

%\begin{document}

%$\ellipsis{x^{#1}}{0}{5}{+}$

%$\ellipsis{x_{#1}}{0}{5}{+}$

%$\ellipsis{(x_{#1}+y_{#1}i)}{1}{n}{}$

%\end{document}
%



%% CNL CONTROL SEQUENCES

\def\ignoreOptionAndCS[#1]#2{}

\def\onearg#1{(onearg:#1)} % for debugging.

\ignoreOptionAndCS[3]\onearg


\def\ignoreOne#1{}

%\ignoreOne\onearg C

\def\ignoreOptionOrCS{%
\futurelet\nextToken\chooseBranch}


\def\chooseBranch{%
\let\next=\relax
\ifx\nextToken [%
 \let\next=\ignoreOptionAndCS%
\else%
 \let\next=\ignoreOne%
\fi%
\next%
}

\def\ignoreOptionAndCSS[#1]#2#3{}
\def\ignoreTwo#1#2{}
\def\ignoreOptionOrCSS{%
\futurelet\nextToken\chooseBranchTwo%
}
\def\chooseBranchTwo{%
\let\next=\relax
\ifx\nextToken [%
 \let\next=\ignoreOptionAndCSS%
\else%
 \let\next=\ignoreTwo%
\fi%
\next%
}

\let\CnlExpand=\ignoreOptionOrCS
\let\CnlNoExpand=\ignoreOptionOrCS
\let\CnlDelete=\ignoreOptionOrCS
\let\CnlCustom=\ignoreOptionOrCSS
\let\CnlDef=\ignoreOptionOrCSS
\let\CnlError=\ignoreOptionOrCS
\def\CnlEnvirDelete#1{}


%% ENVIRONMENTS

\newenvironment{cnl}{}{}
% \leavevmode\par is to make remark work 
% when it is the first item in a subsection.

\newenvironment{remark}%{}{} %temp debug
{\leavevmode\par\begin{tabular}{|p{13cm}}\parskip=\baselineskip{\bf Remark.}}
{\end{tabular}}



\newcommand{\var}[1]{#1}
\newcommand{\id}[1]{#1}
\newcommand{\prefix}[1]{}
\newcommand{\app}[1]{#1}
\newcommand{\CnlList}[1]{#1} % was list
\newcommand{\parenI}[1]{#1}
\renewcommand{\*}{\,}

\renewcommand{\iff}{\leftrightarrow}
\newcommand{\Prop}{\text{\tt Prop}}
\newcommand{\Type}{\text{\tt Type}}
%\newcommand{\fld}{.} %use \h{. }
\newcommand{\dequiv}{\mathrel{:=}} %{\mathrel{:\equiv}}
\newcommand{\assign}{\mathrel{:=}} %{\mathrel{:\equiv}}
\newcommand{\cons}{\mathrel{:\!:}}
%\def\assign{\mathrel{:=}}
\newcommand{\Nat}{\ensuremath{{\mathbb N}}}
\newcommand{\Real}{\ensuremath{{\mathbb R}}}
\newcommand{\Bool}{\ensuremath{{\mathbb {B}}}}
\newcommand{\df}[1]{\text{\bf #1}}
\newcommand{\h}[1]{\text{\color{red} #1}}
\newcommand{\join}{\lor}
\newcommand{\Mid}{\mathrel{\|}}
\newcommand{\comment}[1]{\%- \nobreak{#1}}
%\renewcommand{\~}{\ }
\newcommand{\ignore}[1]{}
\newcommand{\parenthetical}[1]{(#1)}
%\renewcommand{\_}{\textunderscore}
\renewcommand\labelitemi{--}
\renewcommand{\qed}{\ensuremath{\square}}

\def\lsection#1{\section{#1}\label{#1}}
\def\lsubsection#1{\subsection{#1}\label{#1}}
\def\lsubsubsection#1{\subsubsection{#1}\label{#1}}
\def\deflabel#1{\begin{definition}[#1]\label{#1}}
\def\thmlabel#1{\begin{theorem}[#1]\label{#1}}
\def\namelabel#1{[#1]\label{#1}}
\newcommand{\keyword}[1]{{\text{\bf{#1}}}}
\newcommand{\fun}{\keyword{fun}}
\newcommand{\match}{\keyword{match}}
\newcommand{\ifcond}{\keyword{if}}
\newcommand{\thencond}{\keyword{then}}
\newcommand{\elsecond}{\keyword{else}}
\newcommand{\otherwise}{\keyword{otherwise}}
\newcommand{\function}{\keyword{function}}
\newcommand{\quot}{\keyword{quot}}
\newcommand{\where}{\keyword{where}}
\newcommand{\blank}{\h{\_}}

% Accents- Use these versions to fuse with variable name in CNL image.
% \mathcheck{c} --> V__c_mathcheck
% \check{c} --> \check{c} (function application)
\newcommand{\mathhat}{\hat}
\newcommand{\mathwidehat}{\widehat}
\newcommand{\mathcheck}{\check}
\newcommand{\mathtilde}{\tilde}
\newcommand{\mathwidetilde}{\widetilde}
\newcommand{\mathacute}{\acute}
\newcommand{\mathgrave}{\grave}
\newcommand{\mathdot}{\dot}
\newcommand{\mathddot}{\ddot}
\newcommand{\mathbreve}{\breve}
\newcommand{\mathbar}{\bar}
\newcommand{\mathvec}{\vec}

\newcommand{\setcomp}[2]{\{#1 \mid #2\}}
\newcommand{\setenum}[1]{\{#1\}}
\newcommand{\wherearg}[1]{\where\ $\{#1\}$}
\newcommand{\optarg}[1]{\{#1\}}
\newcommand{\inv}[1]{{#1}^{-1}}
\newcommand{\texstop}{.}
\newcommand{\texcomma}{,}
\newcommand{\cnlstop}{}


\begin{cnl}


%% We start with some that will eventually be moved to a standard library.

\CnlCustom[1]\parenI{ (#1) }
\CnlCustom\*{*}
\CnlCustom[1]\lsection{Section \concat{}{#1} .}
\CnlCustom[1]\lsubsection{Subsection \concat{}{#1} .}
\CnlCustom[1]\lsubsubsection{Subsubsection \concat{}{#1} .}
\CnlCustom[1]\deflabel{\begin{definition}\label{#1}}
\CnlCustom[1]\df{ #1 }
\CnlCustom[1]\h{ #1 }
\CnlCustom\where{where}
\CnlCustom\ifcond{if}
\CnlCustom\otherwise{true}
\CnlCustom\elsecond{else}
\CnlCustom\where{where}
\CnlCustom\assign{ \concat{}{:=} }
\CnlCustom\cons{\concat{}{::}} 
\CnlCustom\plural{\concat{/-}{}}
\CnlCustom\wherearg{where}
\CnlCustom\fun{fun}
\CnlCustom\Prop{Prop}
\CnlCustom\Type{Type}
\CnlCustom\iff{iff}
\CnlCustom\optarg{}
\CnlCustom\match{match}
\CnlDelete\par
\CnlDelete\texstop
\CnlCustom\function{function}
\CnlCustom\Bool{Bool}
\CnlCustom\Nat{Nat}
\CnlCustom\Real{Real}
\CnlCustom\quot{quot}
\CnlCustom\alpha{V--alpha}
\CnlCustom\beta{V--beta}
\CnlCustom[2]\prefix{\concat{#1}{#2}}
\CnlCustom\cnlstop{.}
%\CnlCustom\nullbrack{\concat{}{[]}}

% Prohibited control sequences. 
% That is, they should remain outside the cnl environment.
% We should list many TeX primitive control sequences here.

\CnlError\if
\CnlError\else
\CnlError\fi
\CnlError\let
\CnlError\futurelet
\CnlError\expandafter
\CnlError\afterassignment
\CnlError\usepackage
% etc. 

%
\CnlDelete[1]\phantom
\CnlDelete\firstitem
\CnlDelete\texstop
\CnlDelete\texcomma
\CnlCustom\matchitem{\alt}
\CnlCustom\firstmatchitem{\alt}
\CnlCustom[2]\caseif{#2 \assign #1}
\CnlCustom[1]\caseotherwise{true \assign #1}
%\CnlNoExpand[1]\section

% math modes and space
\CnlDelete\ensuremath
\CnlDelete\text
\CnlDelete\thinmuskip
\CnlDelete\medmuskip
\CnlDelete\thickmuskip
\CnlDelete\quad
\CnlDelete\qquad
\CnlDelete\,
\CnlDelete\:
\CnlDelete\;
\CnlDelete\!
\CnlDelete\ %space
\CnlDelete\enspace
\CnlDelete[1]\hspace
\CnlDelete\hfil
\CnlDelete\hfill
\CnlDelete\thinspace
\CnlDelete\left
\CnlDelete\right
\CnlDelete\big
\CnlDelete\Big
\CnlDelete\bigg
\CnlDelete\Bigg
\CnlDelete\allowdisplaybreaks



%other  spacing
\CnlDelete\noindent
\CnlDelete\indent
\CnlDelete[1]\vspace
\CnlDelete\null
\CnlDelete\break
\CnlDelete\newline
\CnlDelete\newpage
\CnlDelete\vfil
\CnlDelete\vfill
\CnlDelete\smallskip
\CnlDelete\medskip
\CnlDelete\bigskip
\CnlDelete[2]\rule
\CnlDelete[1]\parenthetical

\CnlEnvirDelete{remark}
\CnlEnvirDelete{summary}
\CnlEnvirDelete{tikzpicture}
\CnlEnvirDelete{fancyvrb}



\begin{remark}
This is a preliminary text.  It
writes some mathematical statements according to a
controlled natural language for mathematics.
\end{remark}


\lsection{Generalities}

\begin{remark}
This article is an experiment in writing mathematics in a computer
readable format.  It is a preliminary step in the creation of a
controlled natural language based on English with semantics based on
the Calculus of Inductive Constructions (CiC).  We have in mind the
dialect of CiC described in Carneiro's CMU master's thesis, and
implemented in the Lean theorem prover.

The controlled natural language is inspired by earlier CNLs such as
Mizar, Evidence Algorithm (EA), Forthel (formula theory language), SAD
(system of automated deduction), Naproche (natural language proof
checking), etc.

The mathematical content here is not important.  What matters is the
language and the stages of transformation from English to CiC.

Text placed in remarks (such as this text) are not part of the
controlled natural language and are ignored by the translation engine.
\end{remark}


Let $x \ne y$ stand for $\neg(x = y)$.

\begin{remark}
Structures (inductive types with a single constructor) are the basic
building block for all mathematical structures. Whenever a
mathematician defines a mathematical structure as an $n$-tuple
satisfying a list of axioms, we define the corresponding
structure in CiC. The difference is that the components of an
$n$-tuple are distinguished by the ordering of the components, but the
components (that is fields) of a structure are distinguished by naming
each component.

In a structure declaration, a field marked as {\it over} can float out
of the structure and become an unbundled parameter to the structure.
We are relying here on an extension to CiC designed by the author last
year (called Cabarete mode), which facilitates the transformations
between bundled and unbundled structures.

A field marked as {\it type} means that when a value $X$ of that
structure appears in syntax reserved for a type (for example $x : X$
or $f:X \to \alpha$), the value $X$ is coerced to the type field.

A field marked as {\it map} means that when a value $f$ appears in
function application syntax (say $f\ x$), the function $f$ is coerced
to the map field.
\end{remark}

\newpage
\lsection{Set membership}

In this section, let $\alpha,\beta$ denote types.

\deflabel{set over}
Let \df{set over}\ $\alpha$ be the type $\alpha \to\Prop$.
\end{definition}



\deflabel{universe over}
Let \df{universe over} $\alpha$ equal the function
\[
\fun\ (\blank : \alpha) \assign
\h{true}.
\]
\end{definition}

\deflabel{empty set}
Let $\emptyset$ equal
\[
\fun\ (\blank\ : \alpha) \assign \h{false},
\]
inferring $\alpha$.
\end{definition}

Let empty set stand for $\emptyset$.

\begin{remark}
A set $X$ over $\alpha$ is a subset of the universe over $\alpha$. We
follow our general convention of using the preposition {\it over} with
parameters to a type.

Subsets are identified with their characteristic functions, taking
values in \Prop.  Thus, the universe over $\alpha$ is the constant
function from $\alpha$ to \Prop\ taking value true for each input.

The empty set over $\alpha$ is the other extreme.  It is the constant
function taking value false for each input.

In type theory, there is a universe and an empty set for each type:
the universe over the natural numbers, the empty set over the real
numbers, etc.

In the following, we remark that \h{notation-subset} is a type
isomorphic with \h{binary-relation}.
\end{remark}

\begin{remark}
Notational structures are transient structure that assist in parsing,
but that are not passed through to the kernel for type checking.
Non-transient structure implement notations through field synonyms.

Field labels that are variables are anonymous and unify with any field
of the same type.

A field is labeled {\it over} when it may be dislodged into the
position of a structure parameter.

A field is labeled {\it type} when there is a coercion
from values of the structure to that field (which should be a type).
\end{remark}

\deflabel{notation in}
A \h{notation-in} is a notational structure with
\begin{structure}
\firstitem (parameter) $\beta$ % carrier first, to allow dependency.
\item (parameter) $\alpha$
\item \h{notation-in} : $\alpha\to\beta\to \Prop$\texstop
\end{structure}\cnlstop
\end{definition}

\deflabel{in}
Let $x \in X$ denote $C\h{.notation-in}\ x\ X$, inferring (C :
\h{notation-in}).
\end{definition}

\deflabel{notin}
Let $x\notin X$ denote $\h{not}(x\in X)$.
\end{definition}

\deflabel{notation-subset}
A \h{notation-subset} is a notational structure with
\begin{structure}
\firstitem (parameter, type) $\alpha$
\item \h{notation-subseteq} : $\alpha \to \alpha \to \Prop$\texstop
%\item subset $X\ (Y : \alpha)\ \dequiv X \subseteq Y$ and $X\ne Y$
\end{structure}\cnlstop
\end{definition}

\deflabel{subset notation}
Let $X\subset Y$ denote
$C\h{.notation-subset}\ X\ Y$,
inferring $(C : \h{notation-subset})$.
\end{definition}

\begin{remark}
When one definition builds on another that has an implicit variable,
it is not necessary to mention the implicit variable again in the new
definition.
\end{remark}


Let $X\subseteq Y$ denote $X\subset Y$ or $(X=Y)$.

Let $X$ is a \df{subset of} $Y$ stand for $X\subseteq Y$.

Let $x$ is a \df{member of} $X$ stand for $x\in X$.

Let the value of $f$ at $x$ stand for $f(x)$.



\begin{remark}
In the following extension, we pull out the variables $\alpha$ and
$\beta$ for purposes of naming.  The resulting extension is equivalent
to what would be obtained by working with fully bundled structures.

A structure is {\it embedded} (following the terminology of golang) if
all the fields of that structure are inserted into the structure being
declared. The insertion is flat.  That is the fields appear at the top
level (rather than nested) in the structure being declared.
\end{remark}
%\forall

We record a coercion 
\[
\optarg{\alpha; \beta}\ (\h{notation-in}\ \h{over}\ \beta,\alpha) : 
(\h{notation-subset}\ \h{over}\ \beta) \assign
\]
a structure with
\begin{structure}
\firstitem a \h{notation-subset} over $\beta$
with properties
\item for all  $(X\ Y : \beta), \h{we have}\ (X \subseteq Y\ \iff
  \h{for all } x,\ x \in X \rightarrow x \in Y)$\texstop
\end{structure}\cnlstop
This exists and is unique.

\newpage
\lsection{Natural Number}

\begin{remark}
Here we construct the semiring of natural numbers with its standard
notation. Each inductive type, such as the type of natural numbers,
comes wrapped as an object of type \h{typical}
(with the inductive type as a field marked
\emph{type} to create automatic type coercions to the underlying
inductive type).
\end{remark}

\deflabel{typical structure}
An \h{typical-structure} is a structure with
\begin{structure}
\firstitem (type) $\alpha : \Type$\texstop
\end{structure}\cnlstop
\end{definition}

\deflabel{notation zero}
A \h{notation-zero} is a notational structure with
\begin{structure}
\firstitem $\alpha : \Type$
\item $\h{notation-zero} : \alpha$\texstop
\end{structure}\cnlstop
\end{definition}

Let $0$ stand for $C\h{.notation-zero}$, inferring
$(C:\h{notation-zero})$.

\deflabel{notation one}
A \h{notation-one} is a notational structure with
\begin{structure}
\firstitem $\alpha : \Type$
\item \h{notation-one} $ : \alpha$\texstop
\end{structure}\cnlstop
\end{definition}

Let $1$ stand for $C\h{.notation-one}$, inferring
$(C:\h{notation-one})$.

\deflabel{notation add}
A \h{notation-add} is a notational structure with
\begin{structure}
\firstitem $\alpha : \Type$
\item \h{notation-add} $ : \alpha\to\alpha\to\alpha$\texstop
\end{structure}\cnlstop
\end{definition}

\deflabel{notation add}
let $x + y$ stand for $C\h{.notation-add}\ x\ y$ with precedence
$30$ and left associativity, inferring $(C:\h{notation-add})$.
\end{definition}

\deflabel{notation numeral}
A \h{notation-numeral} is a notational structure with
\begin{structure}
\firstitem notation-one
\item notation-add\texstop
\end{structure}\cnlstop
\end{definition}

\begin{remark} A structure that satisfies notation numeral
has automated support for positive numerals
\[
1,2,3,4,\ldots = 1, 1+1, (1+1)+1, ((1+1)+1)+1,\ldots
\]
\end{remark}

\deflabel{notation mul}
A \h{notation-mul} is a notational structure with
\begin{structure}
\firstitem $\alpha : \Type$
\item \h{notation-mul} $ : \alpha\to\alpha\to\alpha$\texstop
\end{structure}\cnlstop
\end{definition}


\deflabel{notation mul}
Let $x \* y$ stand for $C\h{.notation-mul}\ x\ y$ with precedence
$40$ and left associativity, inferring $(C:\h{notation-mul})$.
\end{definition}

\deflabel{natural numbers}
Let $\Nat$ be the inductive type
\begin{envMatch}
\firstmatchitem \h{zero} &$:\ \Nat$ 
\matchitem \h{succ} &$:\ \Nat\to\Nat$
\end{envMatch} with
\begin{itemize}
\firstitem (notation) notation-zero $\assign \h{zero}$
\item (notation) notation-one $\assign \h{succ}\ 0$\texstop
\end{itemize}\cnlstop
\end{definition}

\deflabel{natural number addition}
We define $\h{add}\ (m:\Nat) (n:\Nat) \assign$
\par$\match\ n$ with
\begin{envMatch}
\firstmatchitem $0$ &$\assign$& $m$
\matchitem $\h{succ}\ k$ &$\assign$& $\h{succ}\ (\h{add}\ m\ k)$\texstop
\end{envMatch}\cnlstop
This exists by recursion.
\end{definition}

Moreover, $\Nat$ implements
\begin{itemize}
\firstitem (notation) notation-add $\assign\ \h{add}$
\end{itemize}\cnlstop

\deflabel{natural number multiplication}
We define $\h{mul}\ (m:\Nat) (n:\Nat) \assign$
\par$\match\ n$ with
\begin{envMatch}
\firstmatchitem $0$ &$\assign$& $0$
\matchitem $k+1$ &$\assign$& $\h{succ}\ (\h{mul}\ m\ k  + m)$\texstop
\end{envMatch}\cnlstop
This exists by recursion.
\end{definition}

Moreover, $\Nat$ implements
\begin{itemize}
\firstitem (notation) notation-mul $\assign\ \h{mul}$
\end{itemize}\cnlstop


\newpage
\lsection{List}

\begin{remark}
Intuitively, a list is a finite sequence of elements of the same type.
Lists are one of the fundamental inductive types.  This section
introduces lists, basic operations on lists, and notation.
\end{remark}

In this section, let $\alpha$ denote a type.

\deflabel{list}
Let $\h{list}\ \optarg{\alpha}$ be the inductive type
\begin{envMatch}
\firstmatchitem $\h{null}$ &$:$& $\h{list}$
\matchitem $\h{cons}$ &$:$& $\alpha\to\h{list}\to\h{list}$\texstop
\end{envMatch}\cnlstop
\end{definition}

\deflabel{null list}
Let $\nullbrack$ equal
\[
\h{null} : \h{list}\ {\alpha}.
\]
\end{definition}

\deflabel{cons}
Let $(x : \alpha) \cons (X : \h{list}\ \alpha)$ stand for
\[
\h{list.cons}\ \optarg{\alpha}\ x\ X.
\]
\end{definition}

\deflabel{length}
Let $\h{list.length}\ \optarg{\alpha}\ : \h{list}\to \Nat$ = \par\function
\begin{envMatch}
\firstmatchitem $\nullbrack$ &$\assign$& $0$
\matchitem $a \cons A$ &$\assign$& 1 + \h{length}\ A\texstop
\end{envMatch}\cnlstop
This exists by recursion.
\end{definition}

\deflabel{list.in}
Let $\h{list.in}\ (x : \alpha) : \h{list}\to \Bool$ = \par\function
\begin{envMatch}
\firstmatchitem $\nullbrack$ &$\assign$& \h{false}
\matchitem $a \cons A$ &$\assign$& $(x = a) \lor (\h{in}\ x\ A)$\texstop
\end{envMatch}\cnlstop
This exists by recursion.
\end{definition}

Moreover, list implements
\begin{itemize}
\firstitem (notation) notation-in $(x : \alpha)\ (X : \h{list}) \assign \h{in}\ x\ X$
\end{itemize}\cnlstop

\begin{remark} The drop function removes the first occurrence
of an element from a list
(but does nothing if the element does not belong to the list).
\end{remark}

\deflabel{list.drop}
Let $\h{list.drop}\ (x : \alpha) : \h{list}\to\h{list} \assign$
\par\function
\begin{envMatch}
\firstmatchitem $\nullbrack$ &$\assign$& \nullbrack
\matchitem $a \cons A$ &$\assign$&
$\h{if}\ (x = a)\ \h{then}\ A\ \h{else}\ a \cons (\h{drop}\ x\ A)$\texstop
\end{envMatch}\cnlstop
This exists by recursion.
\end{definition}

\begin{remark} We implement a function that determines whether
one list is a reordering of another list. The function is-permutation
is an equivalence relation on lists.  We are thus able to form
a quotient of lists by this equivalence relation. The resulting
type is the type of multisets, or lists up to permutation.  By
construction a multiset has an enumeration by a list.
\end{remark}

\deflabel{is-permutation}
Let $\h{list.is-permutation}\ X\ Y : \Bool \assign$
\par\match $(X,Y)$ with
\begin{envMatch}
  \firstmatchitem $(\nullbrack,\nullbrack)$ &$\assign$& \h{true}
                  \matchitem [5pt] 
$(x\cons X,y\cons Y)$ &$\assign$&%
$
\left\{
\begin{tabular}{ll}
$\ifcond\ (x=y)\ \thencond\ \h{is-permutation}\ X\ Y$ \\
\elsecond\ $(x\in Y)\land \h{is-permutation}\ X\ (c \cons  (\h{drop}\ x\ Y))$.
\end{tabular}
\right\texstop
$
\end{envMatch}\cnlstop
This exists by recursion.
\end{definition}

\deflabel{multiset} Let \h{multiset}\ $\optarg{\alpha}$ denote the quotient
of \h{list}\ $\optarg{\alpha}$ by the equivalence relation
\h{is-permutation}.  This exists.
\end{definition}

\deflabel{length}
Let \h{multiset.length}\ $(X : multiset)$ denote the length of
$Y$ for each and every $X= \quot\ Y\ \h{is-permutation}$.
This exists and is welldefined.
\end{definition}

\newpage
\lsection{Finiteness}

In this section, let $\alpha$ stand for a type.

\begin{remark}
This section relies on results about lists.

Every list is constructed by a finite process of consing $x \cons  X$ to
the head of a list.  This finite process can be used to say what it
means for other types to be finite.

A value of type duplicate~free~multiset over $\alpha$ represents an
enumerated finite set.
\end{remark}

[synonym size/length]

[synonym element/point/carrier]

\deflabel{nodup multiset}
A \h{duplicate~free~multiset} is a structure with
\begin{structure}
\firstitem (parameter) element : \Type
\item support : multiset $\optarg{element}$
\item length\ $\dequiv$ the length of the support,
  with property
\item noduplicate : nodup support\texstop
  %- a proof that the support set is
 %duplicate free.
\end{structure}\cnlstop
\end{definition}

\begin{remark}
We can specify a bijection from \h{duplicate~free~multiset} to finite sets.

The function takes a simple form, thanks to our notation $\in$ for
multisets, and curly bracket notation for sets.

Once we have a bijection, there are two ways to interpret $\in$ for
\h{duplicate~free~multisets}.  We need compatibility. %XX
\end{remark}


\deflabel{set of nodup multiset}
We record a coercion
\begin{align*}
\h{set-of-duplicate~free~multiset}
\ \optarg{\alpha}\ &(X :
\h{duplicate~free~multiset}\ %
\h{over}\ \alpha) : \h{set over}\ \alpha \\ \assign 
\setcomp{x}{x \in \h{support of}\ X}.
\end{align*}
\end{definition}

%[ (X : set over \alpha) ].
\deflabel{finite}
Assume that $(X : \h{set over}\ \alpha)$.  We say that $X$ is
\df{finite} iff $X$ is a member of the image of
\h{set-of-duplicate~free~multiset}.
\end{definition}

Let an \df{equivalence} $f:\alpha\to\beta$ stand for a bijection $f$.

We record an equivalence\hfil\break
\h{set-of-duplicate~free~multiset}
$\ \optarg{\alpha}\ (X :
\h{duplicate~free~multiset}\ %
\h{over}\ \alpha) : \h{finite set over}\ \alpha $


\begin{remark}
We give infrastructure support for bijective functions that have been
recorded in the form of coercions in both directions between the
two.

The function \h{set-of-duplicate~free~multiset} is an equivalence.  By
recording it as an equivalence, definitions involving
\h{duplicate~free~multiset} automatically extend to finite sets.
\end{remark}

\begin{remark}
Because of the equivalence, size and support are now defined on finite
sets.
\end{remark}

\lsubsection{finite types}

\begin{remark}
We extend the preceding notions from sets to types by using the
universe of a type.  We do not state these definitions formally over
concerns that the parser might have difficulty with the ambiguities
these definitions would create.

We say that $\alpha$ is a \df{finite} type iff the universe over
$\alpha$ is finite.

Assume that $\alpha$ is a finite type.  The \df{size} of $\alpha$ is
the size of the universe over $\alpha$.  This exists and is unique.

Assume that $\alpha$ is a finite type.  The \df{support} of $\alpha$
is the support of the universe over $\alpha$.  This exists and is
unique.

\end{remark}


\newpage
\lsection{Order}

\deflabel{binary relation}
A \df{binary~relation} is a structure with
\begin{structure}
\firstitem (parameter, type) element : \Type
\item a $relation : element \to element \to \Prop$\texstop
  \end{structure}\cnlstop
\end{definition}

In this section, fix a binary relation $R$.

In this section, let $(s\ x\ y\ z : R\h{.element})$.

In this section, let $x \le y$ stand for $R\h{.relation}\ x\ y$.

\deflabel{reflexive} We say $R$ is \df{reflexive} iff for all\ $x,\ x
\le x$.
\end{definition}

\deflabel{transitive} We say $R$ is \df{transitive} iff for
all\ $x\ y\ z,\ x \le y \land y \le z \to x \le z$.
\end{definition}

\deflabel{symmetric} We say $R$ is \df{symmetric} iff for
all\ $x\ y,\ x \le y \to y \le x$.
\end{definition}

\deflabel{preorder} We say $R$ is a \df{preorder} iff $R$ is symmetric
and transitive.
\end{definition}

\deflabel{equivalence relation} We say $R$ is an \df{equivalence
  relation} iff $R$ is reflexive, symmetric and transitive.
\end{definition}

\deflabel{antisymmetric} We say $R$ is \df{antisymmetric} iff for
all\ $x\ y,\ x \le y\ \h{and}\ y \le x\ \h{imply}\ x = y$.
\end{definition}

\deflabel{total} Assume that $R$ is a preorder.  We say that $R$ is
\df{total} iff for all\ $(x\ y),\ x \le y \ \h{or}\ y \le x$.
\end{definition}

\deflabel{poset} We say that $R$ is a \df{poset} iff $R$ is an
antisymmetric preorder.
\end{definition}

Let \df{partially ordered set} stand for poset.

\deflabel{linear order} We say that $R$ is a \df{linear order} iff $R$
is a total poset.
\end{definition}

Let \df{total order} denote linear order.

[synonym greatest/maximum/top]

\deflabel{greatest element} We say that $y$ is a \df{greatest element
  in} $R$ iff for all\ $x,\ x \le y$.
\end{definition}

[synonym least/minimum/bottom]

\deflabel{least element} We say that $y$ is a \df{least element} in
$R$ iff for all\ $x,\ y \le x$.
\end{definition}

Let $x < y$ stand for $x \le y$ and $x \ne y$.

\deflabel{maximal element} We say that $y$ is a \df{maximal element}
in $R$ iff there exists no $x$ such that $y < x$.
\end{definition}

\deflabel{minimal element} We say that $y$ is a \df{minimal element}
in $R$ iff there exists no $x$ such that $x < y$.
\end{definition}

\deflabel{irreflexive} We say that $R$ is \df{irreflexive} iff there
exists no $x$ such that $x < x$.
\end{definition}

\deflabel{asymmetric} We say that $R$ is \df{asymmetric} iff for
all\ $x\ y,\ x < y\ \h{implies that not}\ y < x$.
\end{definition}

\deflabel{strict partial order} We say that $R$ is a
\df{strict~partial~order} iff $R$ is irreflexive, transitive, and
asymmetric.
\end{definition}

Let $S$ denote a set over $R$.

\deflabel{upper bound} We say $x$ is an \df{upper bound} of $S$ in $R$
iff $s \le x\ \h{for all}\ s \in S$.
\end{definition}

\deflabel{lower bound} We say $x$ is a \df{lower bound} of $S$ in $R$
iff $x \le s$ for all $s \in S$.
\end{definition}

\deflabel{wellfounded} We say that $R$ is \df{wellfounded} iff for
every $S$ such that $S\ne \emptyset$ there exists a lower bound $s$ of
$S$ such that $s\in S$.
\end{definition}

[synonym least upper bound/join/supremum]

[synonym greatest lower bound/meet/infimum]

\deflabel{least upper bound} We say $x$ is a \df{least upper bound} of
$S$ in $R$ iff $x$ is an upper bound of $S$ such that for every upper
bound $y$ of $S$ we have $x \le y$.
\end{definition}

\deflabel{greatest lower bound} We say $x$ is a \df{greatest lower
  bound} of $S$ in $R$ iff $x$ is a lower bound of $S$ such that for
every lower bound $y$ of $S$ we have $y \le x$.
\end{definition}

\deflabel{join semilattice} We say $R$ is a \df{join semilattice} iff
for every $(x\ y),$ there exists a least upper bound of $\setenum{x,y}$ in
$R$.
\end{definition}

\deflabel{meet semilattice} We say $R$ is a \df{meet semilattice} iff
for every $x, y$ there exists a greatest lower bound of $\setenum{x,y}$ in
$R$.
\end{definition}

\deflabel{join} Assume $R$ is a join semilattice.  Let
$\h{\df{join}}\ x\ y$ be the least upper bound of $\setenum{x,y}$ in $R$.
This exists and is unique.
\end{definition}

\deflabel{meet} Assume $R$ is a meet semilattice.  Let
$\h{\df{meet}}\ x\ y$ be the greatest lower bound of $\setenum{x,y}$ in $R$.
This exists and is unique.
\end{definition}

\deflabel{lattice} $R$ is a \df{lattice} iff $R$ is a join semilattice
and a meet semilattice.
\end{definition}

\newpage
\lsection{Order Notation}

\deflabel{notation le}
A \h{notation-le} is a notational structure with
\begin{structure}
\firstitem (type) $\alpha : \Type$
\item \h{notation-le} : $\alpha \to \alpha \to \Prop$\texstop
%\item lt $x\ (y : D)\ \dequiv x \le y$ and $x\ne y$
%\item ge $x\ (y : D)\ \dequiv y \le x$
%\item gt $x\ (y : D)\ \dequiv y < x$
%where $D = $\h{element-le}
\end{structure}\cnlstop
\end{definition}

Let $x \le y$ denote $C\h{.notation-le}\ x\ y$, inferring
$(C:\h{notation-le})$.

Let $x < y$ stand for $x \le y$ and $x\ne y$.

Let $x \ge y$ stand for $y \le x$.

Let $x > y$ stand for $y < x$.

Let $m$ is \df{at~most} $n$ stand for $m \le n$.

Let $n$ is \df{at~least} $m$ stand for $n \ge m$.

Let $m$ is \df{less~than} $n$ stand for $m < n$.

Let $n$ is \df{greater~than} $m$ stand for $n > m$.

\newpage
\lsection{More on Natural Numbers}

In this section, let $m,\ n,\ d,\ p,\ r$ denote natural numbers.

\deflabel{nat le}
  We say that $\h{nat-le}\ m \ n$ iff there exists $d$ such that $m + d = n$.
\end{definition}

We record a wellfounded total order, where
\begin{itemize}
\firstitem relation\ $\dequiv \h{nat-le}$
\item (notation) \h{notation-le} $\assign$ relation
\end{itemize}\cnlstop
This exists and is unique.


\begin{remark}
The numbers
$0,\pm1,\pm2,\ldots$ can be interpreted in any structure that
additionally satisfies \h{notation-neg}.
\end{remark}

[synonym number\plural s]

Let \df{natural number} stand for \Nat.

\deflabel{divides}
We say that $d$ \df{divides} $m$ iff $d\ne 0$ and there exists $r$
such that $m= d\*r$.
\end{definition}

\end{cnl}
\def\natdiv#1#2{{#1}\mathrel{|}{#2}}
\begin{cnl}

Let $\natdiv{d}{m}$ stand for $d$ divides $m$.

Let $d$ is a \df{divisor of} $m$ stand for $d$ divides $m$.

\end{cnl}
\def\natpow#1#2{{#1}^{#2}}
\begin{cnl}

\deflabel{natpow}
Assume that $b,n$ are natural numbers.  We define
$\natpow{b}{n}\assign$
\par$\match\ n$ with
\begin{envMatch}
\firstmatchitem $0$ &$\assign$& $1$
\matchitem $m + 1$ &$\assign$& $b \* \natpow{b}{m}$\texstop
\end{envMatch}\cnlstop
This exists by recursion.
\end{definition}

\deflabel{prime}
Assume that $p$ is a natural number greater than $1$.  We say that $p$
is a \df{prime} iff each divisor of $p$ is equal to $1$ or is equal to
$p$.
\end{definition}

\deflabel{multiplicity}
The \df{multiplicity} of $p$ in $n$ is the natural number $m$ such that
\[
\natpow{p}{m}\ \h{divides}\ n\quad \h{and}\ \natpow{p}{m+1}\ %
\h{does not divide}\ n.
\]
This exists and is unique.
\end{definition}

\newpage
\lsection{Group theory}



\deflabel{magma}
A \h{magma} is a structure with
\begin{structure}
\firstitem (type, parameter) element : \Type
\item an $\h{op} : \h{element} \to \h{element} \to \h{element}$
\item (notation) $\h{notation-mul} \assign op$\texstop
\end{structure}\cnlstop
\end{definition}


\begin{remark} XX
The following definition has problems.  The \h{notation-in} is a
dependent type, where the order of the arguments is switched.

We record a coercion $(G : group) : \h{notation-in}\assign$
\begin{itemize}
\firstitem $\beta\assign \h{group}$
\item $\alpha\assign G\h{.element}$
\end{itemize}\cnlstop
\end{remark}

\deflabel{abelian}
Assume that $(M : magma)$.
M is \df{abelian} iff for all $(x\ y : M)$, $x \* y = y \* x$.
\end{definition}

\deflabel{semigroup}
A \df{semigroup} is a structure with
\begin{structure}
\firstitem a magma
with property
\item associativity : for all $(x\ y\ z : 
\h{element}),\ x \* y \* z = (x \* y) \* z$\texstop
\end{structure}\cnlstop
\end{definition}

% for all $(x, y, z : element), x \* y \* z = (x \* y) \* z$.
% for all $x$, $y$ and  $z$, $x \* y \* z = (x \* y) \* z$.
% for all $(x,\ y,\ z : \h{element}),\ x \* y \* z = (x \* y) \* z$.
% for all $x$, $y$ and  $z$, $x \* y \* z = (x \* y) \* z$.

\deflabel{monoid}
 A \df{monoid} is a structure with
\begin{structure}
\firstitem a semigroup
\item a unit: element
\item (notation) $\h{notation-one} \assign \h{unit}$
with property
\item for all\ $x,\ x \* 1 = 1 \* x = x$\texstop
\end{structure}\cnlstop
\end{definition}

\deflabel{notation inverse}
A \h{notation-inverse} is a notational structure with
\begin{structure}
\firstitem (parameter) $\alpha : \Type$
\item \h{notation-inverse} : $\alpha\to\alpha$\texstop
\end{structure}\cnlstop
\end{definition}


Let $\inv{x}$ stand for $C\h{.notation-inverse}\ x$, inferring
$(C:\h{notation-inverse})$,

\deflabel{group}
A \df{group} is a structure with
\begin{structure}
\firstitem a monoid
\item an inv : $C \to C$ with properties
\item (notation) $\h{notation-inverse} \assign \h{inv}$
\item $\forall (x : C),\  x \* \inv{x} = \inv{x} \* x = 1$\texcomma
\end{structure}
\wherearg{C \assign\h{element}}.
\end{definition}

\newpage
\lsection{Ring and modules}

\begin{remark}
An additive group is just a group in which the surface notation has
been altered.  Additive group and group satisfy each other (but the notational
fields drop out).
%The convention is that 'xxx extensions keep field names distinct,
%but satisfaction ignores 'xxx extensions, but gives priority to fewer ''.
\end{remark}


\deflabel{notation neg}
A \h{notation-neg} is a notational structure with
\begin{structure}
\firstitem $\alpha : \Type$
\item $\h{notation-neg} : \alpha\to\alpha$\texstop
\end{structure}\cnlstop
\end{definition}

Let $-x$ stand for $C\h{.notation-neg}\ x$, inferring
$(C:\h{notation-neg})$.


\deflabel{additive group}
An \df{additive group} is a structure with
\begin{structure}
\firstitem a group without notation
\item (notation) $\h{notation-zero} \assign \h{unit}$
\item (notation) $\h{notation-add} \assign \h{op}$
\item (notation) $\h{notation-neg} \assign \h{inv}$\texstop
\end{structure}\cnlstop
\end{definition}


\deflabel{ring}
A \df{ring} is a structure with
\begin{structure}
\firstitem an abelian additive group
\item an $\h{op'}  : C \to C \to C$
\item a $\h{unit'} : C$
\item (notation) $\h{notation-mul} \assign \h{op'}$
\item (notation) $\h{notation-one} \assign \h{unit'}$
with properties
\item \h{unit-axiom'} : $\forall\ x : C,\ 1\*x = x\*1 = x$
\item \h{mul-associativity} : $\forall\ x\ y\ z : C,\ x\*y\*z = x\*(y\*z)$
\item \h{right-distributivity} : $\forall\ x\ y\ z\ : C,\ (x + y)\*z = x\*z + y\*z$
\item \h{left-distributivity}: 
$\forall\ x\ y\ z : C$, $z\*(x+y) = z\*x + z\*y$\texcomma
\end{structure}
\wherearg{C \assign \h{element}}.
\end{definition}


\begin{remark} 
By construction, a ring satisfies a group (with additive structure).
There is a separate map from ring to monoid (with multiplicative
structure), which is achieved with an explicit function call.
\end{remark}


\deflabel{monoid of ring}
We make $\h{monoid-of-ring}\ ($R$ : \h{ring}) : \h{monoid} \assign$
\begin{itemize}
%\item element \assign R\h{.element}
\firstitem unit $\assign R\h{.unit'}$
\item op $\assign R\h{.op'}$
\item \blank
\end{itemize}\cnlstop
\end{definition}


\deflabel{commutative} 
Assume that $R$ is a ring.  We say that $R$ is
\df{commutative} iff for every $(x\ y : R),\ x\*y = y\*x$.
\end{definition}


\deflabel{nontrivial}
Assume that $R$ is a ring.
We say that $R$ is \df{nontrivial} iff $(0 : R) \ne (1 : R)$.
\end{definition}


\deflabel{unit} 
Assume that $R$ is a commutative ring.  Assume that
$(x : R)$.  We say that $x$ is a \df{unit} in $R$ iff there exists $(y
: R)$ such that $x \* y = y \* x = 1$.
\end{definition}


\deflabel{notation dot}
A \h{notation-dot} is a notational structure with
\begin{structure}
\firstitem (parameter, type) $\alpha, \beta : \Type$
\item (notation) \h{notation-dot} : $\alpha \to \beta \to \beta$\texstop
\end{structure}\cnlstop
\end{definition}

Let $r \cdot x$ stand for $C\h{.notation-dot}\ r\ x$ with precedence
$50$ and left associativity, inferring $(C:\h{notation-dot})$.


\deflabel{left module}
A \df{left module} is a structure with
\begin{structure}
\firstitem (parameter) $R$ : ring
\item an  additive group
\item a \h{scalar-multiplication} : 
$R\h{.element} $\to$ element $\to$ element
\item (notation) $\h{notation-dot} \assign \h{scalar-multiplication}$
with properties
\item \h{left-linear} : 
for all $r,x,y,\ r \cdot (x + y) = r \cdot x + r \cdot y$
\item \h{right-linear} : 
for all $r,s,x,\ (r + s) \cdot x = r \cdot x + s \cdot x$
\item multiplicative : 
for all $r,s,x,\ (r\*s) \cdot x = r \cdot (s \cdot x)$
\item unital : for all $x,\ 1 \cdot x = x$\texstop
\end{structure}\cnlstop
\end{definition}

\newpage
\lsection{The field of real numbers}

\deflabel{field}
A \df{field} $R$ is a nontrivial commutative ring such that for all $x\ne 0$,  $x$ is a unit in $R$.
\end{definition}

\deflabel{vector space}
  A \df{vector space} is a structure with
  \begin{structure}
\firstitem a left module
\item (parameter) $R$ : field\texstop
  \end{structure}\cnlstop
\end{definition}


\deflabel{ordered ring}
An \df{ordered ring} is a structure with
\begin{structure}
\firstitem a ring
\item a linear order with properties
\item (notation) $\h{notation-le} \assign$ relation
\item for all $(x\ y\ z)$, if $x \le y$ then $x + z \le y + z$
\item for all $(x\ y)$, if $0\le a$ and $0\le b$, then $0\le a\*b$\texstop
\end{structure}\cnlstop
\end{definition}

\begin{remark}
See \url{https://en.wikipedia.org/wiki/Ordered-ring}
\end{remark}

\deflabel{ordered field}
An \df{ordered field} is a a structure with
\begin{structure}
\firstitem an  ordered ring
\item a field\texstop
\end{structure}\cnlstop
\end{definition}

\deflabel{complete}
Assume that $F$ is an ordered field.
We say that $F$ is \df{complete} iff
for every subset $S$ of the universe of $F$,
  if $S \ne \emptyset$ and $S$ has an upper bound in $F$ then $S$ has a least upper bound in $F$.
\end{definition}

\deflabel{absolute value}
Let
$\h{ordered-field.absolute-value}\ (x : \h{element}): \h{element}\assign$ 
\[
\begin{cases}
\firstmatchitem \caseif{\phantom{-}x}{0 \le x}
\matchitem \caseotherwise{-x}\texstop
\end{cases}\cnlstop
\]
This exists and is unique and total.
\end{definition}


\deflabel{isomorphism of complete ordered fields} 
Assume that $F$ and $G$ are complete ordered fields.
An isomorphism of complete ordered fields $F,\ G$ is a bijection
\[
f:F\to G
\]
such that 
\begin{align*}
&\forall x\ y,\ f(x+y) = f(x) + f(y) \land f(x\* y) = f(x)\* f(y)\quad \land \\
&\forall x\ y,\ x\le y\ \iff\ f(x) \le f(y).
\end{align*}
\end{definition}

%\deflabel{cof canonical} 
%Let \h{cof-canonical} \parenthetical{short
%  for complete ordered field} be the \h{canonical-isomorphism} such
%that
%\begin{itemize}
%\item $A \assign \h{complete ordered field}$
%\item $B\ F_1\ F_2 \assign \h{Iso}\ F_1\ F_2$
%\item $\h{arrow}\ F_1\ F_2 \assign$ the unique element of $\h{Iso}\ F_1\ F_2$
%\end{itemize}\cnlstop
%This exists and is unique.
%\end{definition}

\begin{remark}
For every complete ordered fields $F,\ G$, there exists a unique
isomorphism of complete ordered fields $F,\ G$.  We may transport
structure across these isomorphisms.
\end{remark}

\deflabel{real}
Let \Real\ be the complete ordered field.
This exists and is canonical.
\end{definition}

\lsubsection{norms}

Let $|(x:\Real)|$ denote \h{absolute-value}\ $x$.

\deflabel{normed commutative ring}
  A \df{normed commutative ring} is a structure with
  \begin{structure}
\firstitem a commutative ring
\item an \h{absolute-value} : element $\to \Real$
with properties
\item \h{non-negativity} : for all $x$, $A\ x = 0 \iff x = 0$
\item \h{triangle-inequality} : for all $x\ y,\ A (x + y) \le A\ x + A\ y$
\item submultiplicative : for all $x\ y, A(x \* y) \le (A\ x) \* (A\ y)$\texcomma
  % See https://ncatlab.org/nlab/show/normed+ring
\end{structure}
\wherearg{A \assign \h{absolute-value}}.
\end{definition}

\deflabel{normed field}
  A \df{normed field} is a structure with
  \begin{structure}
\firstitem a normed commutative ring
\item a field\texstop
  \end{structure}\cnlstop
\end{definition}


\lsubsection{meet semilattice of subgroups}

\begin{remark}
We introduce the semilattice of subgroups explicitly.  Each subgroup
is characterized by its set of elements.  A subgroup is not literally
a group.  It would take a coercion to make it so.

Because of the way parameters work, we say that $H$ is a subgroup {\it
  over} $G$.
\end{remark}

\deflabel{subgroup}
A \df{subgroup}  is a structure with
\begin{structure}
\firstitem (parameter) \h{ambient-group} : group
\item (type) support $: \h{set over}\ \h{ambient-group}$
with properties
\item nonempty : $1 \in support$ and
\item closure : for all $x,y \in \h{support}, x \* \inv{y} \in \h{support}$\texstop
\end{structure}\cnlstop
\end{definition}


\deflabel{subgroup semilattice} Let 
\h{subgroup-semilattice}
$(G :\h{group}) : \h{meet-semilattice}\assign$
\begin{itemize}
\firstitem $\h{element}\ \assign \h{subgroup over}\ G$
\item $\h{relation}\ H_1\ H_2 \assign \h{for all}\ x,\ x \in H_1 \to x \in
H_2$
\item \blank
\end{itemize}\cnlstop
This exists and is unique.
\end{definition}

\begin{remark} At this point, we could introduce notation
$\subseteq$, $\cap$, etc. for subgroups over a given group.

In the following definition of subgroup order, the parentheses around
(subgroup) indicate that the qualifier \emph{subgroup} appears in the
\LaTeX\ file, but is not displayed in the pdf.
\end{remark}

Assume that $G$ is a finite group, let
the \df{order} of $G$ stand for the size of $G$.

\deflabel{subgroup order}
Assume that $H$ is a subgroup over a finite group $G$.
The \parenthetical{subgroup} \prefix{subgroup~}{order} of $H$ is the size of the support of $H$.
This exists and is well subtyped \parenthetical{that is, $H$ is finite}.
\end{definition}

\newpage
\lsection{Sylows Theorems}

In this section, let $G$ denote a fixed finite group.

\end{cnl}
\def\conj#1#2{{#1}{#2}{#1}^{-1}}
\begin{cnl}

In this section, let $\conj{g}{X}$ stand for
\[
\setcomp{g\*x\*\inv{g}}{x\in X},
\]
\where\ $(g : G)$ $(X : \h{set}\ G)$.

\deflabel{conjugate}
Assume that $(g : G)$.  Assume that $H$ is a subgroup over $G$.  The
\df{conjugate} of $H$ by $g$ in $G$ is the subgroup $\conj{g}{H}$ over $G$.
\end{definition}

\deflabel{normalizer}
Assume that $H$ is a subgroup over $G$.  The \df{normalizer of} $H$
\df{in} $G$ is the subgroup $N$ over $G$ such that for all $x$, $x \in N
\iff \conj{x}{H}=H$. This
exists and is unique.
\end{definition}


Let $|G|$ denote the order of $G$.

In this section, let $p$ denote a fixed prime number.

\end{cnl}
\def\mult#1#2{m}
\def\Syl#1#2{\operatorname{Syl}_{#1}(#2)}
\def\SylN#1#2{n_{#1}(#2)}
\def\Nz#1#2{|N(#1,#2)|}
\begin{cnl}

In this section, let $\mult{p}{G}$ denote the multiplicity of $p$ in
$|G|$.


\deflabel{Sylow}
A \df{Sylow $p$ subgroup of} $G$ is a subgroup $P$ over $G$ such that
the \prefix{subgroup~}{order} of $P$ is $\natpow{p}{\mult{p}{G}}$.
\end{definition}


\begin{definition}
Let $\Syl{p}{G} = 
\setcomp{P}{(P\ \h{is a Sylow}\ p\ \h{subgroup of}\ G)}$.
\end{definition}



Let $\SylN{p}{G}$ denote the size of $\Syl{p}{G}$.  This is well
subtyped \parenthetical{that is, there are finitely many Sylow $p$
  subgroups}.



\begin{definition}
Let $\Nz{p}{G}$ be equal to
the size of the normalizer of each and every Sylow $p$ subgroup of $G$.
This exists, is unique, and is well-defined.
\end{definition}

\begin{theorem}[Sylow1]
There exists a Sylow $p$ subgroup of $G$.
\end{theorem}

\begin{theorem}[Sylow 2]
If $P, P'$ are Sylow $p$ subgroups of $G$ then there exists $(g : G)$
such that $P' = \conj{g}{P}$.
\end{theorem}

\begin{theorem}[Sylow 3a]
Assume that $|G| = p'\*\natpow{p}{m}$.
We have $\SylN{p}{G}$ divides $p'$.
\end{theorem}

\begin{theorem}[Sylow 3b]
We have $p$ divides $(\SylN{p}{G} - 1)$.
\end{theorem}

\begin{theorem}[Sylow 3c]
We have $\SylN{p}{G}\*\Nz{p}{G} = |G|$.
\end{theorem}

\end{cnl}


\end{document}
