%{

(* open Program *)
type exp_t = 
| prop_t
| proof_t
| type_t
| term_t 
[@@deriving show]

 %}



%start <string> program

%%

program : {}

(* parametrized nonterminals *)
paren(X) : L_PAREN x = X R_PAREN { x }
bracket(X) : L_BRACK x = X R_BRACK { x }
brace(X) : L_BRACE x = X R_BRACE { x }
brace_semi(X) : brace(separated_nonempty_list(SEMI,X) {}) {}

comma_nonempty_list(X) : separated_nonempty_list(COMMA,X) {}
comma_list(X) : separated_list(COMMA,X) {}
opt_comma_nonempty_list(X) : separated_nonempty_list(option(COMMA),X) {}
sep_list(X) : separated_list(sep_and_comma,X) {}

(* from phrase_lists.txt. These will need to be
expanded in the working parser. *)
phrase_list_transition : XX {}
phrase_list_filler : XX {}
phrase_list_proof_statement : XX {}

(* literals *)

lit_a : LIT_A | LIT_AN {}
article : lit_a | LIT_THE {}
sep_and_comma : LIT_AND | COMMA {}
separator : COMMA | SEMI | PERIOD {}
delimiter : L_PAREN | R_PAREN | L_BRACK | R_BRACK | L_BRACE | R_BRACE {}
identifier : ATOMIC_IDENTIFIER | HIERARCHICAL_IDENTIFIER {}

(* more literals *)
lit_define : option(LIT_WE) LIT_DEFINE {}
lit_defined_as : LIT_SAID LIT_TO LIT_BE 
| LIT_DEFINED LIT_AS
| LIT_DEFINED LIT_TO LIT_BE {}
lit_iff : LIT_IFF | LIT_IF LIT_AND LIT_ONLY LIT_IF {}
lit_denote : LIT_STAND LIT_FOR | LIT_DENOTE {}
lit_do : LIT_DO | LIT_DOES {}
lit_is : LIT_IS | LIT_ARE | option(LIT_TO) LIT_BE {}
lit_has : LIT_HAS | LIT_HAVE {}
lit_with : LIT_WITH | LIT_OF | LIT_HAVING {}
lit_true : LIT_ON | LIT_TRUE | LIT_YES {}
lit_false : LIT_OFF | LIT_FALSE | LIT_NO {}
lit_its_wrong : LIT_IT LIT_IS LIT_WRONG LIT_THAT {}
lit_any : (* can extend: finitely many, almost all, etc. *)
| LIT_EVERY 
| LIT_EACH 
| LIT_EACH LIT_AND LIT_EVERY 
| LIT_ALL 
| LIT_ANY 
| LIT_SOME 
| LIT_NO {}
lit_exist : LIT_EXIST | LIT_EXISTS {}
lit_def : LIT_DEF | LIT_DEFINITION {}
lit_axiom : LIT_AXIOM | LIT_CONJECTURE | LIT_HYPOTHESIS {}
lit_theorem : 
| LIT_PROPOSITION 
| LIT_THEOREM 
| LIT_LEMMA 
| LIT_COROLLARY {}
lit_lets : LIT_LET LIT_US | LIT_WE option(LIT_CAN) {}
lit_assume : LIT_ASSUME | LIT_SUPPOSE {}
lit_then : LIT_THEN | LIT_THEREFORE | LIT_HENCE {}
lit_choose : LIT_TAKE | LIT_CHOOSE {}
lit_prove : LIT_PROVE | LIT_SHOW {}
lit_we_say : LIT_WE LIT_SAY option(LIT_THAT) {}

label : ATOMIC_IDENTIFIER {}


(* symb_or_sep : separator | SYMBOL {}
 symb_token : SYMBOL {}
| symb_sep nonempty_list(symb_sep) {} *)
var_modifier : LIT_FIXED | LIT_IMPLICIT {}
tvar : VAR | paren(option(var_modifier) VAR colon_type {}) {}
tvar2 : tvar COMMA tvar | paren(VAR option(COMMA) VAR colon_type {}) {}
pvars : paren(option(var_modifier) opt_comma_nonempty_list(VAR) colon_type {}) {}
ptvar : pvars | tvar {}
tvars : opt_comma_nonempty_list( ptvar) {} 
names : opt_comma_nonempty_list(tvar) {}

colon_type : COLON type_expr {}
opt_colon_type : option(colon_type) {}


punctuation : delimiter | separator {}
lexeme : NUMERIC | identifier | FIELD_ACCESSOR | SYMBOL | punctuation {}

(* primitives *)

prim_classifier : {} (* meta-type words like "function" "element" "object" "number" "quotient" "dependent function" "thing" "class" "map" "structure" "term" "binary relation" "relation" "operator" "binary operator" *) 

prim_symbol_cs : {} 
prim_alpha_cs : {}

prim_lambda_binder : {}(* term binders *)
prim_pi_binder : {}(* type binders*)
prim_binder_prop : {}

prim_typed_name : {} (* correspond to Lean types, quotient of type by term, type of term, etc. *)
prim_universe : LIT_TYPE | LIT_PROP {}
prim_quantifier_prop : {} (* used in quantifier scoping (class_relation) *)
prim_adjective : {}
prim_adjective_mutual : {}

prim_simple_adjective : {} (* autogenerated, those with no args *)
prim_simple_adjective_mutual : {} (* mutual version, autogenerated from prim_adjective_mutual, no args *)

prim_definite_noun : {} (* functions and terms *)
prim_plain_noun : {} (* autogenerated from prim_definite_noun *)
prim_prefix_function : {} (* functions like sin,cos,exp *)
prim_possessed_noun : {} (* autogenerated as in Forthel *)
prim_verb : {}
prim_verb_mutual : {} (* mutual version *)
prim_structure : {} (* CIC structures *)
prim_op : {} (* symbolic operators on terms *)
prim_relation : {} (* prop-valued *)


(* Instructions - See Naproche-SAD github Instr.hs. Test:Instructions  *)
instruction :
| instruct_command
| instruct_synonym
| instruct_string 
| instruct_bool 
| instruct_int {}

  instruct_keyword_command : LIT_EXIT {}
  instruct_keyword_int : LIT_TIMELIMIT {}
  instruct_keyword_bool : LIT_PRINTGOAL | LIT_DUMP | LIT_ONTORED {}

  instruct_keyword_string : LIT_READ | LIT_LIBRARY {}

  instruct_command : bracket( instruct_keyword_command) {}
  instruct_int : bracket(instruct_keyword_int NUMBER {}) {}
  bool_tf : lit_true | lit_false {}
  instruct_bool : bracket(instruct_keyword_bool bool_tf {}){}
  instruct_string : bracket(instruct_keyword_string TOKEN {}) {}
  instruct_sep : SLASH | SLASHDASH {} 
  instruct_synonym : bracket(LIT_SYNONYM 
    separated_nonempty_list (instruct_sep,nonempty_list(TOKEN)) {}) {}

(* PATTERNS AND MACROS *)


macro : option(insection) sep_list(assuming) macro_body {}
  assuming : LIT_ASSUMING option(LIT_THAT) statement{}
  insection : LIT_IN LIT_THIS section_tag {}
  macro_body : notion_macro | function_macro | predicate_macro {}
  notion_macro : LIT_LET notion_pattern lit_denote lit_a type_expr PERIOD {}
  function_macro : LIT_LET function_pattern lit_denote term {}
  predicate_macro : 
  | LIT_LET predicate_token_pattern lit_denote statement {}
  | LIT_LET symbol_pattern lit_denote statement {}


(* token_pattern_item : list(tokens tvar {}) {} *)
token_pattern : tokens list(tvar tokens {}) option(tvar) {}
tokens : nonempty_list(TOKEN) {} 
(* restriction: no token should be a variant of the verb to be, or iff *)
symbol_pattern : option(tvar) SYMBOL list(tvar SYMBOL {}) option(tvar) {}
| identifier paren(tvar list(COMMA tvar {}) {}) {}
| identifier option(tvar) {}
notion_pattern : option(lit_a) token_pattern {}
function_pattern : LIT_THE token_pattern | symbol_pattern {}
predicate_token_pattern : 
| tvar LIT_IS token_pattern {}
| tvar token_pattern {}


(* ATTRIBUTES (FORTHEL STYLE) *)

left_attribute : prim_simple_adjective | prim_simple_adjective_mutual {}

right_attribute : sep_list(is_pred) {}
| LIT_THAT sep_list(does_pred) {}
| LIT_SUCH LIT_THAT statement {}




named_terms : sep_list(option(lit_a) named_term {}) {}
named_term : type_expr | quantifier_prop {}

paren_class_relation : prim_quantifier_prop 
| paren(prim_quantifier_prop {}) {}

quantifier_prop : list(left_attribute) paren_class_relation option(right_attribute) {}
quantified_notion : lit_any LIT_NOTION {}

(* syntax for types.*)

type_expr : 
| arrow_type
| agda_pi_type
| paren_type
| annotated_type
| app_type
| const_type
| var_type
| subtype {}

(* root_type : prim_typed_name | paren_type | annotated_type | const_type | var_type{} *)
attribute_names  : list(left_attribute) prim_typed_name option(right_attribute) {}
arrow_type : type_expr ARROW type_expr {}
agda_pi_type : paren(var_term colon_type {}) ARROW type_expr {}
paren_type : paren(type_expr) {}
annotated_type : paren(type_expr COLON LIT_TYPE {}) {}

app_type : type_expr nonempty_list(expr) {}

type_identifier : identifier {}
const_type : type_identifier {}
var_type : VAR {}

subtype :  brace(term option(LIT_FIXING comma_nonempty_list(VAR) {}) LIT_MMID term {}) {}





(* inductive and mutual inductive are distinguished by context not keyword mutual.*)

inductive_type : LIT_INDUCTIVE type_identifier list(pvars) opt_colon_type
list(inductive_constructor) LIT_END{}

mutual_inductive_type : LIT_INDUCTIVE
comma_nonempty_list(type_identifier) list(pidentifiers)
list(LIT_WITH ATOMIC_IDENTIFIER list(pidentifiers) colon_type
 list(ALT identifier_term list(pidentifiers) colon_type {}) {}) LIT_END{}

pidentifiers : paren(opt_comma_nonempty_list(ATOMIC_IDENTIFIER) opt_colon_type {}) {}
inductive_constructor : ALT identifier_term list(pidentifiers) opt_colon_type{}






(* unsorted *)

var_name_type : XX {}

(* syntax for props *)


prop : binder_prop 
| identifier_prop {}

binder_prop : prim_binder_prop option(opt_arg) tvars COMMA prop {}

identifier_prop : identifier {}



(* syntax for proofs *)
proof_expr : SYMBOL_QED {}


(* Lean style syntax for terms *)

term : 
match_term
| case_term 
| make_term 
| app_term 
| identifier_term 
| var_term 
| lambda_term 
| let_term 
| annotated_term 
| list_term 
| tuple_term 
| set_enum_term 
| set_comprehension_term 
| if_then_else_term 
| BLANK {}
terms : sep_list(term) {}

app_term : term nonempty_list(expr) {}

var_term : VAR {}
annotated_term : paren(term colon_type {}) {}
identifier_term : identifier {}

match_term : LIT_MATCH match_seq LIT_WITH nonempty_list(ALT match_pats ASSIGN term {}) LIT_END {}
  match_seq : comma_nonempty_list(term) {}
  match_pats : comma_nonempty_list(match_pat) {}
  match_pat : term {}

(* case staement. *)
case_term : LIT_CASE term LIT_OF nonempty_list(case_pattern) LIT_END {}
  case_pattern : ALT prop ASSIGN term {} 

(* Haskell style "where" expression *)
where_term : brace_semi(tvar opt_colon_type ASSIGN term {}) {}

(* Lean style make. (We have freed up braces.) *)
make_term : brace_semi(identifier option(ASSIGN term {}) option(SEMI BLANK {}) {}) opt_colon_type {}


lambda_term : prim_lambda_binder option(opt_arg) tvars COMMA term {}
lambda_fun : LIT_FUN identifier option(opt_arg {}) tvars opt_colon_type ASSIGN term {}
opt_arg : brace_semi(identifier opt_colon_type {}) {}
opt_arg_assign_term : brace_semi(identifier ASSIGN term {}) (* function named args.*) {}
lambda_function : LIT_FUNCTION identifier option(opt_arg) tvars opt_colon_type nonempty_list(ALT match_pats ASSIGN term {}) LIT_END {}

list_term : bracket(separated_list(SEMI,term) {}) {}

tuple_term : paren(term COMMA comma_nonempty_list(term) {}) {}

set_enum_term : brace(comma_list(term) {}) {}
set_comprehension_term : brace(term option(LIT_FIXING comma_nonempty_list(VAR) {}) LIT_MID term {}) {}

(* let includes destructuring*)
let_term : LIT_LET term ASSIGN term LIT_IN term {}
if_then_else_term : LIT_IF prop LIT_THEN term LIT_ELSE term {}


(* EXPRESSIONS *)

expr : type_expr | term | prop | proof_expr {}

(* declaration of structure *)

structure : option(lit_a) prim_structure LIT_IS lit_a anon_structure {}
anon_structure : LIT_STRUCTURE option(with_param) fields 
  option(satisfying_preds) {}
field_key : LIT_EMBEDDED 
| LIT_PARAMETRIC 
| LIT_TYPEABLE 
| LIT_APPLICABLE {}
with_param : LIT_WITH LIT_PARAMETERS tvars {}
fields : LIT_WITH nonempty_list(field) {}
field_prefix : ALT list(field_key) {}
field_suffix : LIT_WITHOUT LIT_NOTATION | field_assign {}
field_name : ATOMIC_IDENTIFIER colon_type | var_name_type {}
field : field_prefix field_name option(field_suffix) {}
satisfying_preds : LIT_SATISFYING nonempty_list(satisfying_pred) {}
satisfying_pred : ALT option(ATOMIC_IDENTIFIER COLON {}) prop {}
field_assign : ASSIGN term {}

symbol_term : tvar | XX {}

definite_term : symbol_term
| option(LIT_THE) prim_definite_noun
| paren(option(LIT_THE) prim_definite_noun {}) {}


(* predicates *)
does_pred : option(lit_do) option(LIT_NOT) prim_verb {}
| option(lit_do) option(LIT_NOT) prim_verb_mutual
| lit_has has_pred
| lit_is sep_list(is_pred)
| lit_is sep_list(is_aPred {}) {}

is_pred : option(LIT_NOT) prim_adjective {}
| option(LIT_NOT) option(LIT_PAIRWISE) prim_adjective_mutual
| lit_with has_pred {}

is_aPred : option(LIT_NOT) option(lit_a) type_expr {}
| option(LIT_NOT) definite_term {}

has_pred : sep_list(article possessed_noun {}) {}
| LIT_NO possessed_noun {}

possessed_noun : list(left_attribute) prim_possessed_noun option(right_attribute) {}

(* statements *)
(* This might be merged with TDOP prop parsing *)

statement : head_statement | chain_statement {}
  head_statement : LIT_FOR sep_list(quantified_notion {}) statement {}
  | LIT_IF statement COMMA LIT_THEN statement (* != if-then-else *)
  | lit_its_wrong statement {}
  chain_statement : and_chain option(LIT_AND head_statement {}) 
  | or_chain option(LIT_OR head_statement {}) {}
  | and_or_chain LIT_IFF statement {}
  and_or_chain : and_chain | or_chain {}
  and_chain : separated_nonempty_list(LIT_AND, primary_statement {}) {}
  or_chain : separated_nonempty_list(LIT_OR, primary_statement {}) {}

(* primary statement *)
primary_statement : 
  | simple_statement {}
  | there_is_statement
  | option(phrase_list_filler) symbol_statement
  | option(phrase_list_filler) const_statement {}
  simple_statement : terms separated_nonempty_list(LIT_AND, does_pred) {}
  there_is_statement : LIT_THERE lit_exist named_terms {}
  | LIT_THERE lit_exist LIT_NO named_term {}
  const_statement : option(LIT_THE) LIT_THESIS {}
  | option(LIT_THE) LIT_CONTRARY
  | lit_a LIT_CONTRADICTION {}
  symbol_statement : 
  | LIT_FORALL quantifier_prop COMMA 
    symbol_statement {} 
  | LIT_EXISTS quantifier_prop COMMA symbol_statement
  | prim_relation
  | LIT_NOT symbol_statement
  | paren(statement)
  | symbol_predicate {}
  symbol_predicate : XX {}


(* SECTIONS test:Sections *)

section_preamble : section_tag option(label) PERIOD {}
  section_tag : LIT_DOCUMENT 
  | LIT_ARTICLE 
  | LIT_SECTION 
  | LIT_SUBSECTION 
  | LIT_SUBSUBSECTION {} 

(* NAMESPACES  *)

cnl_module : XX {}


(* text *)
text : list(text_item) {}
  text_item : cnl_module 
    | macro 
    | section_preamble 
    | declaration 
    | instruction {}

(* declaration test:declaration *)
declaration : axiom | definition | theorem  {}

(* axiom *)
axiom : axiom_preamble list(assumption) affirm_prefix statement PERIOD {}
  axiom_preamble : lit_axiom option(label) PERIOD {}
  assumption : assumption_prefix statement PERIOD {}
  assumption_prefix : LIT_LET | lit_lets lit_assume option(LIT_THAT) {}

(* definition *)
definition : definition_preamble list(assumption) definition_affirm {}
  definition_preamble : lit_def option(label) PERIOD {}
  definition_affirm : definition_statement PERIOD option(this_exists) {}

definition_statement : notion_def | function_def | predicate_def {}
  macro_junction : lit_is option(lit_defined_as) | ASSIGN | lit_denote {}
  iff_junction : lit_iff {} 

  notion_def : notion_head macro_junction lit_a type_expr {}
    notion_head : option(lit_a) prim_typed_name | notion_pattern {}

  function_def : function_head macro_junction option(LIT_EQUAL LIT_TO {}) 
    option(LIT_THE) term {}
    function_head : option(lit_define) option(LIT_THE) prim_definite_noun 
    | function_pattern {}

  predicate_def : predicate_head iff_junction statement {}
  predicate_head : option(lit_we_say) tvar LIT_IS option(LIT_CALLED) 
    prim_adjective {}
  | option(lit_we_say) tvar2 LIT_ARE option(LIT_CALLED) 
    prim_adjective_mutual
  | option(lit_we_say) tvar prim_verb
  | option(lit_we_say) tvar2 prim_verb_mutual
  | option(lit_we_say) prim_relation
  | option(lit_we_say) predicate_token_pattern {}


(* theorem *)
theorem : theorem_preamble list(assumption) affirm {}
  theorem_preamble : lit_theorem option(label) PERIOD {}
  affirm : affirm_prefix statement option(ref) PERIOD 
    option(proof_preamble proof_script qed {})
  | affirm_prefix statement option(ref) PERIOD 
    LIT_INDEED short_proof_script {}
  | proof_prefix statement option(ref) PERIOD proof_script qed {}
  affirm_prefix : option(LIT_THEN){}

(* proofs *)
proof_script : list(proof_body) proof_tail{}
  proof_body : affirm | choose | assumption | case {}
  proof_tail : affirm | choose | case {}
  proof_preamble : LIT_PROOF option(LIT_BY proof_method {}) PERIOD
  | LIT_INDEED {}
  short_proof_script : affirm {}
  proof_method : LIT_CONTRADICTION 
    | LIT_CASE LIT_ANALYSIS 
    | LIT_INDUCTION option(LIT_ON term {}) {}
  proof_prefix : option(lit_lets) 
    lit_prove option(LIT_BY proof_method {}) option(LIT_THAT) {}
  case : LIT_CASE statement PERIOD proof_script qed {}
  choose : choose_prefix named_terms option(ref) PERIOD 
    option(proof_prefix proof_script qed {}) {}
  choose_prefix : affirm_prefix option(lit_lets) lit_choose {}
  ref : paren(LIT_BY sep_list(label) {}) {}
  qed : LIT_QED | LIT_OBVIOUS | LIT_TRIVIAL PERIOD {}

(* This exists and is well-defined. *)
this_exists : LIT_THIS 
  sep_list(this_directive_pred) PERIOD {} 
  this_directive_pred : LIT_IS 
    sep_list(this_directive_adjective) 
    | this_directive_verb {}
  this_directive_adjective : 
    | LIT_UNIQUE 
    | LIT_CANONICAL 
    | LIT_WELLDEFINED 
    | LIT_WELL_DEFINED 
    | LIT_WELL LIT_DEFINED 
    | LIT_TOTAL 
    | LIT_WELL LIT_PROPPED 
    | LIT_WELL_PROPPED 
    | LIT_EXHAUSTIVE {}
  this_directive_right_attr : LIT_BY LIT_RECURSION {}
  this_directive_verb : LIT_EXISTS option(this_directive_right_attr){}

program : text { "done" } 

