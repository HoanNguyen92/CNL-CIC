%{

(*open Program *)

 %}


%token <string> STRING
%token <string> CONTROLSEQ (* \cs *)

%token <string> NUMBER (*digit+ *)
%token <string> DECIMAL (*digit+ . digit+ *)
%token <string> NUMERIC (*(+|-)? (number | decimal) *)
%token <string> SYMBOL 
%token <string> L_PAREN
%token <string> R_PAREN
%token <string> L_BRACK
%token <string> R_BRACK
%token <string> L_BRACE
%token <string> R_BRACE
%token <string> PERIOD
%token <string> COMMA
%token <string> SEMI
%token <string> ASSIGN
%token <string> BLANK (* _*)
%token <string> ALT
%token <string> SLASH
%token <string> SLASHDASH
%token <string> VAR (*alpha (digit | ')* *)
%token <string> TOKEN
%token <string> WORD (*alpha (alphanum)**)
%token <string> XX (*error*)

%token <string>
LIT_A
LIT_ALL
LIT_AN
LIT_ANALYSIS
LIT_AND
LIT_ANY
LIT_APPLICABLE
LIT_ARE
LIT_ARTICLE
LIT_ASSUME
LIT_ASSUMING
LIT_BE
LIT_BY
LIT_CAN
LIT_CANONICAL
LIT_CASE
LIT_CONJECTURE
LIT_CONTRADICTION
LIT_CONTRARY
LIT_COROLLARY
LIT_DEF
LIT_DEFINED
LIT_DEFINITION
LIT_DENOTE
LIT_DO
LIT_DOCUMENT
LIT_DOES
LIT_DONE
LIT_DUMP
LIT_EACH
LIT_ELSE
LIT_EMBEDDED
LIT_END
LIT_EQUAL
LIT_EVERY
LIT_EXHAUSTIVE
LIT_EXIST
LIT_EXISTS
LIT_EXIT
LIT_FALSE
LIT_FIXED
LIT_FIXING
LIT_FOR
LIT_FORALL
LIT_FUN
LIT_FUNCTION
LIT_HAS
LIT_HAVE
LIT_HAVING
LIT_HENCE
LIT_IF
LIT_IFF
LIT_IMPLICIT
LIT_IN
LIT_INDEED
LIT_INDUCTION
LIT_INDUCTIVE
LIT_IS
LIT_IT
LIT_LEMMA
LIT_LET
LIT_LIBRARY
LIT_MATCH
LIT_NO
LIT_NOT
LIT_NOTATION
LIT_NOTION
LIT_OBVIOUS
LIT_OF
LIT_OFF
LIT_ON
LIT_ONLY
LIT_ONTORED
LIT_OR
LIT_PAIRWISE
LIT_PARAMETERS
LIT_PARAMETRIC
LIT_PRINTGOAL
LIT_PROOF
LIT_PROP
LIT_PROPOSITION
LIT_PROPPED
LIT_QED
LIT_READ
LIT_RECURSION
LIT_SATISFYING
LIT_SECTION
LIT_SOME
LIT_STAND
LIT_STRUCTURE
LIT_SUBSECTION
LIT_SUBSUBSECTION
LIT_SUCH
LIT_SUPPOSE
LIT_THAT
LIT_THE
LIT_THEN
LIT_THEOREM
LIT_THERE
LIT_THEREFORE
LIT_THESIS
LIT_THIS
LIT_TIMELIMIT
LIT_TO
LIT_TOTAL
LIT_TRIVIAL
LIT_TRUE
LIT_TYPE
LIT_TYPEABLE
LIT_UNIQUE
LIT_US
LIT_VARIANT
LIT_WE
LIT_WELL
LIT_WELLDEFINED
LIT_WELL_DEFINED
LIT_WELL_PROPPED
LIT_WITH
LIT_WITHOUT
LIT_WRONG
LIT_YES


%token EOF


%start <string> program

%%

program : {}

(*% CNL literals are LIT_WORD standing for word *)

a_an : LIT_A | LIT_AN {}
article : a_an | LIT_THE {}
prose_sep : LIT_AND | COMMA {}
separator : COMMA | SEMI | PERIOD {}
delimiter : L_PAREN | R_PAREN | L_BRACK | R_BRACK | L_BRACE | R_BRACE {}
symb_or_sep : separator | SYMBOL {}
symb_token : SYMBOL {}
| symb_sep nonempty_list(symb_sep) {}
var_modifier : LIT_FIXED | LIT_IMPLICIT {}
tvar : var | L_PAREN option(var_modifier) var COLON ctype R_PAREN {}
tvar2 : tvar COMMA tvar | L_PAREN var option(COMMA) var COLON ctype {}
pvars : L_PAREN option(var_modifier) separated_nonempty_list(option(COMMA),var) COLON ctype R_PAREN {}
ptvars : pvars | tvar {}
tvars : separated_nonempty_list(option(COMMA), ptvar) {} 
names : separated_nonempty_list(option(COMMA),tvar) {}


punctuation : delimiter | separator {}
lexeme : NUMERIC | WORD | symb_token | punctuation {}

(*% primitives *)

prim_classifier : {} (* meta-type words like "function" "element" "object" "number" "quotient" "dependent function" "thing" *) 

prim_symbol_cs : {} 
prim_alpha_cs : {}

prim_lambda_binder : {}(* term binders *)
prim_pi_binder : {}(* type binders*)

prim_type : {} (* correspond to Lean types, quotient of type by term, type of term, etc. *)
prim_universe : LIT_TYPE | LIT_PROP {}
prim_quantifier_prop : {} (* used in quantifier scoping (class_relation) *)
prim_adjective : {}
prim_adjectiveM : {}

prim_simple_adjective : {} (* autogenerated, those with no args *)
prim_simple_adjectiveM : {} (* mutual version, autogenerated from prim_adjectiveM, no args *)

prim_definite_noun : {} (* functions and terms *)
prim_plain_noun : {} (* autogenerated from prim_definite_noun *)
prim_prefix_function : {} (* functions like sin,cos,exp *)
prim_possessed_noun : {} (* autogenerated as in Forthel *)
prim_verb : {}
prim_verbM : {} (* mutual version *)
prim_structure : {} (* CiC structures *)
prim_op : {} (* symbolic operators on terms *)
prim_relation : {} (* prop-valued *)


(*% Instructions - See Naproche-SAD github Instr.hs *)

prim_keyword_command : LIT_EXIT {}
prim_keyword_int : LIT_TIMELIMIT {}
prim_keyword_bool : LIT_PRINTGOAL | LIT_DUMP | LIT_ONTORED {}

bool_true : LIT_ON | LIT_TRUE | LIT_YES {}
bool_false : LIT_OFF | LIT_FALSE | LIT_NO {}
prim_keyword_string : LIT_READ | LIT_LIBRARY {}

instruct_command : L_BRACK prim_keyword_command R_BRACK {}
instruct_int : L_BRACK prim_keyword_int number R_BRACK {}
bool_tf : bool_true | bool_false {}
instruct_bool : L_BRACK prim_keyword_bool bool_tf R_BRACK {}
instruct_string : L_BRACK prim_keyword_string token R_BRACK {}
instruct_sep : SLASH | SLASHDASH {} 
instruct_variant : L_BRACK LIT_VARIANT nonempty_separated_list (option(instruct_sep),token) R_BRACK {}
instruction : instruct_command | instruct_variant | instruct_string | instruct_bool | instruct_int {}





(*% SECTIONS *)
section_tag : LIT_DOCUMENT | LIT_ARTICLE | LIT_SECTION | LIT_SUBSECTION | LIT_SUBSUBSECTION {} 
section_header : section_tag option(word) PERIOD {}

(*% Declaration this statements. *)
this_def : LIT_THIS separated_nonempty_list(SEP,this_def_pred) {} 
this_def_pred : LIT_IS separated_nonempty_list(prose_sep,this_def_adjective) | this_def_verb {}
this_def_adjective : LIT_UNIQUE | LIT_CANONICAL | LIT_WELLDEFINED | LIT_WELL_DEFINED | LIT_WELL LIT_DEFINED | LIT_TOTAL | LIT_WELL LIT_PROPPED | LIT_WELL_PROPPED | LIT_EXHAUSTIVE {}
this_def_right_attr : LIT_BY LIT_RECURSION {}
this_def_verb : LIT_EXISTS option(this_def_right_attr){}

(*% MODULES (XX insert) *)

(*% PATTERNS AND MACROS *)


assuming : LIT_ASSUMING option(LIT_THAT) statement{}
insection : LIT_IN LIT_THIS section_tag {}
macro : option(insection) separated_list(sep,assuming) macroBody {}

macro_pattern_item : list(nonempty_list(token) tvar {}) {}
macro_pattern : nonempty_list(token) option(tvar list(macro_pattern_item) {}) {}
symbP : option(tvar) symbToken list(tvar symbToken {}) option(tvar) {}
| word L_PAREN tvar list(sep tvar {}) R_PAREN {}
| word option(tvar) {}
notionP : option(aAn) macro_pattern {}
functionP : LIT_THE macro_pattern | symbP {}
predicateP : tvar LIT_IS macro_pattern {}
| tvar macro_pattern {}
| symbP {}
denote : LIT_STAND LIT_FOR | LIT_DENOTE {}
macroBody :notionMacro | functionMacro | predicateMacro {}
notionMacro : LIT_LET notionP denote aAn ctype PERIOD {}
functionMacro : LIT_LET functionP denote term {}
predicateMacro : LIT_LET predicateP denote statement {}




defS :notionDef | functionDef | predicateDef {}
isJunction : LIT_IS | assign {}
notionDef :notionHead isJunction aAn ctype {}
functionDef : functionHead isJunction option(LIT_EQUAL LIT_TO {}) option(LIT_THE) term {}
iffJunction : LIT_IFF | LIT_IF LIT_AND LIT_ONLY LIT_IF {}
predicateDef : predicateHead iffJunction statement {}




notionHead : option(aAn) primType | notionP {}
functionHead :option(LIT_THE) primDefiniteNoun | functionPattern {}
predicateHead :tvar LIT_IS primAdjective {}
| tvar2 LIT_ARE primAdjectiveM
| tvar primVerb
| tvar2 primVerbM
| primRelation
| predicateP {}




leftAttrib : primSimpleAdjective | primSimpleAdjectiveM {}
rightAttrib : isPred list(sep isPred {}) {}
| LIT_THAT doesPred list(sep doesPred {}) {}
| LIT_SUCH LIT_THAT statement {}




notions : option(aAn) notion list(sep option(aAn) notion {}) {}
notion :ctype | quantifier_prop {}
ctype : list(leftAttrib) primType option(rightAttrib) {}
parenClassRelation : primClassRelation | L_PAREN primClassRelation R_PAREN {}
quantifier_prop : list(leftAttrib) parenClassRelation option(rightAttrib) {}
lit_qadj : LIT_EVERY | LIT_EACH | LIT_EACH LIT_AND LIT_EVERY | LIT_ALL | LIT_ANY | LIT_SOME | LIT_NO {}
quantifiedNotion : lit_qadj LIT_NOTION {}





term :matchExpr| XX {}
terms :term list(sep term {}) {}
proofterm :qed {}
universe : LIT_PROP | LIT_TYPE{}
prop : XX {}
varNameType : XX {}





matchExpr : LIT_MATCH matchSeq LIT_WITH nonempty_list(ALT matchPats ASSIGN term {}) LIT_END {}
matchSeq : separated_nonempty_list(COMMA,term) {}
matchPats : separated_nonempty_list(pattern list(sep matchPat {}) {}) {}
matchPat : term {}


(* Case staement. *)
caseExpr : LIT_CASE term LIT_OF nonempty_list(casePattern) LIT_END {}
casePattern : ALT prop ASSIGN term {} 

(* Haskell style where expression *)
whereExpr : L_BRACE separated_nonempty_list(SEMI,tvar ASSIGN term {}) R_BRACE {}

(* Lean style make. (We have freed up curly brackets.) *)
makeExpr : L_BRACE separated_nonempty_list(SEMI, identifier option(ASSIGN term {}) {}) option(SEMI BLANK {}) R_BRACE option(COLON ctype {}) {}


lambda_term :prim_lambda_binder option(opt_arg) tvars COMMA term {}
lambda_fun : LIT_FUN word option(opt_arg {}) tvars option(SEMI ctype {}) ASSIGN term {}
opt_arg : L_BRACE separated_nonempty_list(SEMI, word option(COLON ctype {}) {}) R_BRACE{}
opt_arg_assign_term : L_BRACE separated_nonempty_list(SEMI,word ASSIGN term {}) R_BRACE (* function named args.*) {}
lambda_function : LIT_FUNCTION word option(opt_arg) tvars option(SEMI ctype {}) nonempty_list(ALT matchPats ASSIGN term {}) LIT_END {}

list_term : L_BRACK separated_list(SEMI,term) R_BRACK {}

tuple_term : L_PAREN term COMMA separated_nonempty_list(COMMA,term) R_PAREN {}

set_enum_term : L_BRACE separated_list(COMMA,term) R_BRACE {}
set_comprehension_term : L_BRACE term option(LIT_FIXING separated_nonempty_list(COMMA,var) {}) ALT term R_BRACE {}

(* let includes destructuring*)
let_term : LIT_LET term ASSIGN term LIT_IN term {}
if_then_else_term : LIT_IF prop LIT_THEN term LIT_ELSE term {}


(*% TYPES *)

(* inductive and mutual inductive are distinguished by context not keyword mutual.*)
pidentifiers : L_PAREN separated_nonempty_list(option(COMMA),identifier) option(COLON ctype {}) R_PAREN{}
inductive_constructor : ALT identifier list(pidentifiers) option(COLON ctype {}){}

inductive_type : LIT_INDUCTIVE identifier list(pvars) option(COLON ctype {})
 list(inductive_constructor) LIT_END{}

mutual_inductive_type : LIT_INDUCTIVE
identifier  nonempty_list(COMMA identifier {})  list(pidentifiers)
list(LIT_WITH  identifier  list(pidentifiers) COLON  ctype
 list(ALT  identifier list(pidentifiers) COLON  ctype {}) {}) LIT_END{}






(* function specs *)


structure : option(aAn) primStructure LIT_IS aAn anonStructure {}
anonStructure : LIT_STRUCTURE option(withParam) fields option(satisfyingPreds) {}
fieldKey : LIT_EMBEDDED | LIT_PARAMETRIC | LIT_TYPEABLE | LIT_APPLICABLE {}
withParam : LIT_WITH LIT_PARAMETERS tvars {}
fields : LIT_WITH nonempty_list(field) {}
fieldPrefix : ALT list(fieldKey) {}
fieldSuffix : LIT_WITHOUT LIT_NOTATION | fieldAssign {}
field_name : word COLON ctype | varNameType {}
field : fieldPrefix field_name  option(fieldSuffix) {}
satisfyingPreds : LIT_SATISFYING nonempty_list(satisfyingPred) {}
satisfyingPred : ALT option(word COLON {}) predicate {}
fieldAssign : ASSIGN term {}



symbTerm : tvar | XX {}



lit_do : LIT_DO | LIT_DOES {}
is : LIT_IS | LIT_ARE | LIT_BE {}
has : LIT_HAS | LIT_HAVE {}
doesPred : option(lit_do) option(LIT_NOT) primVerb {}
| option(lit_do) option(LIT_NOT) primVerbM
| has hasPred
| is isPred list(sep isPred {})
| is isAPred list(sep isAPred {}) {}
lit_with : LIT_WITH | LIT_OF | LIT_HAVING {}
isPred : option(LIT_NOT) primAdjective {}
| option(LIT_NOT) option(LIT_PAIRWISE) primAdjectiveM
|  lit_with hasPred {}
isAPred : option(LIT_NOT) option(aAn) ctype {}
| option(LIT_NOT) definiteTerm {}
hasPred : article possNoun list(sep article possNoun {}) {}
| no possNoun {}
possNoun : list(leftAttrib) primPossessNoun option(rightAttrib) {}


statement : headS | chainS {}
headS : LIT_FOR quantifiedNotion list(sep quantifiedNotion {}) statement {}
| LIT_IF statement LIT_THEN statement(* prose then-statement, there is also if-then-else. *)
| LIT_IT LIT_IS LIT_WRONG LIT_THAT statement {}
chainS : andChain option(LIT_AND headS {}) | orChain option(LIT_OR headS {}) {}
andChain : primaryS list(LIT_AND primaryS {}) {}
orChain : primaryS list(LIT_OR primaryS {}) {}


primaryS : simpleS {}
| thereIsS
| option(LIT_WE LIT_HAVE {}) symbS
| option(LIT_WE LIT_HAVE {}) constS {}
simpleS : terms doesPred list(LIT_AND doesPred {}) {}
lit_exist : LIT_EXIST | LIT_EXITS {}
thereIsS : LIT_THERE lit_exist notions {}
| LIT_THERE lit_exist LIT_NO notion {}
constS : option(LIT_THE) LIT_THESIS {}
| option(LIT_THE) LIT_CONTRARY
| aAn LIT_CONTRADICTION {}
symbS : LIT_FORALL quantifier_prop COMMA symbS(* class_relation in Forthel *) {}
| LIT_EXISTS quantifier_prop COMMA symbS
| primRelation
| LIT_NOT symbS
| L_PAREN statement R_PAREN
| symbolPredicate {}


text_item : cnl_module | macro | sectionHeader | toplevel | instruction {}
text : list(text_item) {}
toplevel : axiom | def | proposition {}
axiom : axiomHeader list(assume) axiomAffirm {}
axiomHeader : axiom option(label) PERIOD {}
def : defHeader list(assume) defAffirm {}
lit_def : LIT_DEF | LIT_DEFINITION {}
defHeader :  lit_def option(label) PERIOD {}
proposition : propositionHeader list(assume) affirm {}
lit_prop : LIT_CONJECTURE | LIT_PROPOSITION | LIT_THEOREM | LIT_LEMMA | LIT_COROLLARY {} 
propositionHeader : lit_prop option(label) PERIOD {}
label : word {}
assume : asmPrefix statement PERIOD {}
lit_lets : LIT_LET LIT_US | LIT_WE LIT_CAN {}
lit_assume :LIT_ASSUME | LIT_SUPPOSE {}
asmPrefix : LIT_LET | lit_lets lit_assume  option(LIT_THAT) {}
axiomAffirm : statement PERIOD {}
defAffirm : defS PERIOD option(thisDef) {}
affirm : affPrefix statement option(ref) PERIOD option(prfHeader proof qed PERIOD {}) {}
lit_then :LIT_THEN | LIT_THEREFORE | LIT_HENCE {}
affPrefix : option(lit_then){}
prfHeader : LIT_PROOF option(LIT_BY prf_method {}) PERIOD | LIT_INDEED {}
prf_method : LIT_CONTRADICTION | LIT_CASE LIT_ANALYSIS | LIT_INDUCTION option(LIT_ON term {}) {}
proof :{} 
ref : L_PAREN LIT_BY label option(sep list(label) {}) R_PAREN {}
qed : LIT_QED | LIT_OBVIOUS | LIT_TRIVIAL{}

program : LIT_DONE { "done" } 

